# Xss

## 存储 XSS

eg: 用户在回复的时候，在回复中插入一段<script>标签，服务端存储并且返回给前端展示的时候执行了恶意这段 js 脚本。

## 反射 XSS

eg: 后端服务器有时候会利用 url 上的 query 来动态地返回一些东西，攻击者可以在 query 上拼接攻击脚本

## Dom based

eg: 和反射型 XSS 差不多，只不过是前端存取 query

## self xss

eg: 用户自己在控制台执行，恶意的浏览器插件

## 防御方式

### Sanitization

将用户的输入消毒过滤，比如讲<script>的尖括号转义。

### CSP

内容安全策略，限制脚本的执行范围。当你设置了合理的 CSP 之后，就算你的网站存在 XSS 漏洞，但是攻击者也无法窃取用户信息，因为向别的网站发送请求的时候，如果不在 CSP 的白名单内，就会被浏览器禁止。一般来说，CSP 会从后端的 res 里设置,当然在前端使用<meta>标签也可以设置。

### Httponly Cookie

HttpOnly Cookie 和 CSP 一样，都是降低 XSS 影响的方式。一般来说，我们用来判断用户信息的 AccessToken 都会做 httponly 处理，并且禁止在客户端进行读取，防止伪造登录，你想在客户端判断用户信息可以使用`uin`这样的数据。

## XSS扫描工具

[XSpear](https://github.com/hahwul/XSpear)

# CSRF

简单来讲，就是比如你登陆了抖音，然后过了一会你又登陆了拼多多，这个时候拼多多的网页给抖音的网页发了个请求，抖音还以为是你发的。说到底其实就是抖音服务器的锅，当然我感觉浏览器也得至少背一半。

为什么抖音以为请求是你发的？ 因为浏览器在向网站发请求的时候会默认把你的cookie带上，而服务器是只认cookie的。

## 服务器端防御

### 检查referer和origin

这个解决办法不是很好，因为你有可能把用户的请求也给挡了。

### Verify Code

对于比较重要的请求，比如资金相关的，可以出一个图形验证码

## 浏览器防御

### CSRF TOKEN

简单来说，就是让你的页面发请求的时候都带上一个token，服务器哪里也存一个，一比就知道这个请求是不是你发的。

### 双重cookie

用户访问页面的时候，服务端随机注入一个cookie，比如randomToken=123456,请求的时候从cookie里面把这个拿出来拼接到url上带上给后端验证。

### Samesite Cookie

从源头上解决问题，拼多多的网页给抖音发请求凭什么带上我的cookie？不让带就行了。当然，这个还得综合考虑一样，比如当你有一系列网页的时候，你可能不想用户跳转的时候丢失登陆状态。

#### 同源策略

协议，端口，主机都相同，则同源

# MIME sniffing

一般我们加载文件的时候，res里会返回Content-Type，来指定文件类型。但是，如果没有指定的话，浏览器可能会自己推断文件类型并且加载。

比如当网站有上传svg的功能，而我上传了一个看似是svg实际上里面都是javascript的文件，可能会导致这段恶意javascript的执行。

https://blackfan.ru/mime-type/image-svg-xml.php

解决方法： 设置 X-Content-Type-Options: nosniff，禁止浏览器的默认行为。

# 旁路攻击

当浏览器提供了高精度的时间的时候，攻击者可以从两次请求的间隔时间中判断服务器的状态。

解决办法： 不用解决，之前performace api提供高精度时间和 sharebuffer有漏洞获取高进度时间，了解即可。


